import Foundationimport Combinestruct PokemonService {    private let baseURL = "https://pokeapi.co/api/v2/"    private let urlSession: URLSession    private let decoder: JSONDecoder        init(urlSession: URLSession = .shared) {        self.urlSession = urlSession        self.decoder = JSONDecoder()        self.decoder.keyDecodingStrategy = .convertFromSnakeCase    }        func fetchPokemons(offset: Int, limit: Int) -> AnyPublisher<[Pokemon], Error> {        guard let url = URL(string: "\(baseURL)pokemon?offset=\(offset)&limit=\(limit)") else {            return Fail(error: URLError(.badURL)).eraseToAnyPublisher()        }                return urlSession.dataTaskPublisher(for: url)            .tryMap { data, response in                guard let httpResponse = response as? HTTPURLResponse,                      200..<300 ~= httpResponse.statusCode else {                    throw URLError(.badServerResponse)                }                return data            }            .decode(type: PokemonListResponse.self, decoder: self.decoder)            .map(\.results)            .handleEvents(                receiveOutput: { pokemons in                    print("Successfully fetched \(pokemons.count) pokÃ©mons")                },                receiveCompletion: { completion in                    if case .failure(let error) = completion {                        print("Failed to fetch pokÃ©mons: \(error.localizedDescription)")                    }                }            )            .eraseToAnyPublisher()    }        func fetchPokemonDetails(id: Int) async throws -> PokemonDetails {        guard let url = URL(string: "\(baseURL)pokemon/\(id)") else {            throw URLError(.badURL)        }                let (data, _) = try await urlSession.data(from: url)                if let jsonString = String(data: data, encoding: .utf8) {            print("ðŸ” JSON Recebido:\n\(jsonString)")        }                do {            let rawDetails = try self.decoder.decode(RawPokemonDetails.self, from: data)                        return PokemonDetails(                id: rawDetails.id,                name: rawDetails.name.capitalized,                height: rawDetails.height,                weight: rawDetails.weight,                stats: rawDetails.stats.map { statWrapper in                    PokemonStat(name: statWrapper.stat.name.replacingOccurrences(of: "-", with: " ").capitalized, value: statWrapper.baseStat)                },                types: rawDetails.types.map { $0.type.name.capitalized },                imageUrl: rawDetails.sprites.frontDefault // Removed '?' here            )        } catch {            print("âŒ Erro de decodificaÃ§Ã£o detalhado: \(error)")            throw error        }    }    private func fetchRawPokemonDetails(id: Int) async throws -> RawPokemonDetails {        guard let url = URL(string: "\(baseURL)pokemon/\(id)") else {            throw URLError(.badURL)        }                let (data, _) = try await urlSession.data(from: url)        return try decoder.decode(RawPokemonDetails.self, from: data)    }}// MARK: - Decoding Modelsstruct PokemonListResponse: Codable {    let results: [Pokemon]}