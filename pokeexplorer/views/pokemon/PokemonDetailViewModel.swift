import Foundationimport Combineimport SwiftDataclass PokemonDetailViewModel: ObservableObject {    @Published var pokemonDetails: PokemonDetails?    @Published var isLoading = false    @Published var error: String?    @Published var isFavorite: Bool = false    @Published var animateHeart: Bool = false    let pokemon: Pokemon    private let service: PokemonService        private var modelContext: ModelContext    private var authManager: AuthManager    init(pokemon: Pokemon, service: PokemonService = PokemonService(), modelContext: ModelContext, authManager: AuthManager) {        self.pokemon = pokemon        self.service = service        self.modelContext = modelContext        self.authManager = authManager        loadPokemonDetails()    }        func loadPokemonDetails() {        guard let pokemonId = pokemon.pokemonId else {            error = "Invalid Pokémon ID"            return        }                isLoading = true        error = nil                Task { @MainActor in            do {                let details = try await service.fetchPokemonDetails(id: pokemonId)                self.pokemonDetails = details                self.isLoading = false                self.checkIfFavorite()            } catch {                self.error = error.localizedDescription                self.isLoading = false            }        }    }        var pokemonName: String {        pokemon.name.capitalized    }        var pokemonImageURL: URL? {        URL(string: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/\(pokemon.pokemonId ?? 0).png")    }        var formattedTypes: String {        guard let types = pokemonDetails?.types else { return "Unknown" }        return types.map { $0.capitalized }.joined(separator: ", ")    }        var formattedStats: [StatDisplay] {        guard let stats = pokemonDetails?.stats else { return [] }        return stats.map { StatDisplay(name: $0.name, value: $0.value) }    }        var formattedHeight: String {        guard let height = pokemonDetails?.height else { return "Unknown" }        return String(format: "%.1f m", Double(height) / 10.0)    }        var formattedWeight: String {        guard let weight = pokemonDetails?.weight else { return "Unknown" }        return String(format: "%.1f kg", Double(weight) / 10.0)    }        struct StatDisplay: Identifiable {        let id = UUID()        let name: String        let value: Int    }    @MainActor    func toggleFavorite() {        guard let currentPokemonId = pokemonDetails?.id,              let currentPokemonName = pokemonDetails?.name,              let userEmail = authManager.currentUser?.email else {            self.error = "Unable to identify Pokémon or user for favoriting."            return        }                let predicate = #Predicate<FavoritePokemon> { favorite in            favorite.pokemonId == currentPokemonId && favorite.userId == userEmail        }                do {            let existingFavorites = try modelContext.fetch(FetchDescriptor(predicate: predicate))                        if let favoriteToDelete = existingFavorites.first {                modelContext.delete(favoriteToDelete)                isFavorite = false                print("Pokémon \(currentPokemonName) removed from favorites.")            } else {                let newFavorite = FavoritePokemon(                    pokemonId: currentPokemonId,                    pokemonName: currentPokemonName,                    userId: userEmail,                    dateAdded: Date()                )                modelContext.insert(newFavorite)                isFavorite = true                print("Pokémon \(currentPokemonName) added to favorites.")                                animateHeart = true                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {                    self.animateHeart = false                }            }            try modelContext.save()        } catch {            self.error = "Error managing favorites: \(error.localizedDescription)"            print("SwiftData error when favoriting: \(error.localizedDescription)")        }    }        @MainActor    private func checkIfFavorite() {        guard let currentPokemonId = pokemonDetails?.id,              let userEmail = authManager.currentUser?.email else {            isFavorite = false            return        }                let predicate = #Predicate<FavoritePokemon> { favorite in            favorite.pokemonId == currentPokemonId && favorite.userId == userEmail        }                do {            let existingFavorites = try modelContext.fetch(FetchDescriptor(predicate: predicate))            isFavorite = !existingFavorites.isEmpty        } catch {            print("Error checking favorite: \(error.localizedDescription)")            isFavorite = false        }    }}