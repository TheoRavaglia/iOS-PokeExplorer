import Foundationimport Combineclass PokemonDetailViewModel: ObservableObject {    @Published var pokemonDetails: PokemonDetails?    @Published var isLoading = false    @Published var error: String?        let pokemon: Pokemon    private let service: PokemonService    private var cancellables = Set<AnyCancellable>()        init(pokemon: Pokemon, service: PokemonService = PokemonService()) {        self.pokemon = pokemon        self.service = service        loadPokemonDetails()    }        func loadPokemonDetails() {        guard let pokemonId = pokemon.pokemonId else {            error = "Invalid Pok√©mon ID"            return        }                isLoading = true        error = nil                Task {            do {                let details = try await service.fetchPokemonDetails(id: pokemonId)                DispatchQueue.main.async {                    self.pokemonDetails = details                    self.isLoading = false                }            } catch {                DispatchQueue.main.async {                    self.error = error.localizedDescription                    self.isLoading = false                }            }        }    }        // Helper properties for the view    var pokemonName: String {        pokemon.name.capitalized    }        var pokemonImageURL: URL? {        URL(string: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/\(pokemon.pokemonId ?? 0).png")    }        var formattedTypes: String {        guard let types = pokemonDetails?.types else { return "Unknown" }        return types.map { $0.capitalized }.joined(separator: ", ")    }        var formattedStats: [StatDisplay] {        guard let stats = pokemonDetails?.stats else { return [] }        return stats.map { StatDisplay(name: $0.name, value: $0.value) }    }        struct StatDisplay: Identifiable {        let id = UUID()        let name: String        let value: Int    }}