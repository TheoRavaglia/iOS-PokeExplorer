import SwiftUIimport Combineclass PokemonListViewModel: ObservableObject {    @Published var pokemons: [Pokemon] = []    @Published var isLoading = false    @Published var error: String?    @Published var searchText = ""    private var cancellables = Set<AnyCancellable>()    private let service = PokemonService()    private var offset = 0    private let limit = 20    var filteredPokemons: [Pokemon] {        guard !searchText.isEmpty else { return pokemons }        return pokemons.filter { $0.name.lowercased().contains(searchText.lowercased()) }    }    init() {        setupSearch()        fetchPokemons()    }    func fetchPokemons() {        guard !isLoading else { return }        isLoading = true        error = nil        service.fetchPokemons(offset: offset, limit: limit)            .receive(on: DispatchQueue.main)            .sink { [weak self] completion in                self?.isLoading = false                if case .failure(let error) = completion {                    self?.error = error.localizedDescription                }            } receiveValue: { [weak self] newPokemons in                self?.pokemons.append(contentsOf: newPokemons)                self?.offset += self?.limit ?? 20            }            .store(in: &cancellables)    }    func refresh() {        offset = 0        pokemons.removeAll()        fetchPokemons()    }    private func setupSearch() {        $searchText            .debounce(for: .milliseconds(300), scheduler: RunLoop.main)            .removeDuplicates()            .sink { [weak self] _ in                self?.refresh()            }            .store(in: &cancellables)    }}