import SwiftUIstruct RegisterView: View {    @StateObject private var viewModel = RegisterViewModel()    @Environment(\.presentationMode) var presentationMode        // Estados para animações    @State private var isRegistering = false    @State private var shakeEffect = false    @State private var showSuccess = false        var body: some View {        NavigationView {            // MODIFICAÇÃO: Adicionado ScrollView para permitir rolagem em telas menores (como iPhone deitado)            ScrollView {                VStack(spacing: 20) {                    // Header (sem alterações)                    VStack {                        if showSuccess {                            Image(systemName: "checkmark.circle.fill")                                .resizable()                                .scaledToFit()                                .frame(width: 80, height: 80)                                .foregroundColor(.green)                                .transition(.scale.combined(with: .opacity))                        } else {                            Image(systemName: "person.crop.circle.badge.plus")                                .resizable()                                .scaledToFit()                                .frame(width: 80, height: 80)                                .foregroundColor(.blue)                        }                                                Text("Criar Nova Conta")                            .font(.title)                            .fontWeight(.bold)                    }                    .padding(.top, 20)                                        // Campos de formulário (sem alterações)                    VStack(spacing: 15) {                        TextField("Nome Completo", text: $viewModel.nome)                            .padding()                            .background(Color(.systemGray6))                            .cornerRadius(10)                            .autocapitalization(.words)                            .modifier(ShakeEffect(shake: viewModel.mostrarErro && viewModel.nome.isEmpty))                                                TextField("Email", text: $viewModel.email)                            .padding()                            .background(Color(.systemGray6))                            .cornerRadius(10)                            .keyboardType(.emailAddress)                            .autocapitalization(.none)                            .modifier(ShakeEffect(shake: viewModel.mostrarErro && !viewModel.email.isValidEmail()))                                                SecureField("Senha", text: $viewModel.senha)                            .padding()                            .background(Color(.systemGray6))                            .cornerRadius(10)                            .modifier(ShakeEffect(shake: viewModel.mostrarErro && viewModel.senha.count < 6))                                                SecureField("Confirmar Senha", text: $viewModel.confirmarSenha)                            .padding()                            .background(Color(.systemGray6))                            .cornerRadius(10)                            .modifier(ShakeEffect(shake: viewModel.mostrarErro && viewModel.senha != viewModel.confirmarSenha))                    }                    .padding(.horizontal)                                        // Botão de registro (sem alterações)                    Button(action: {                        // ... sua lógica de registro ...                        withAnimation {                            isRegistering = true                        }                                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {                            if viewModel.registrar() {                                withAnimation(.spring()) {                                    showSuccess = true                                }                                                                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {                                    presentationMode.wrappedValue.dismiss()                                }                            } else {                                withAnimation(.default) {                                    shakeEffect = true                                }                                                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {                                    shakeEffect = false                                }                            }                                                        isRegistering = false                        }                    }) {                        HStack(spacing: 15) {                            if isRegistering {                                ProgressView().tint(.white)                            }                                                        Text(isRegistering ? "Processando..." : "Registrar")                                .fontWeight(.bold)                                .foregroundColor(.white)                        }                        .frame(maxWidth: .infinity)                        .padding()                        .background(Color.blue)                        .cornerRadius(10)                    }                    .padding(.horizontal)                    .padding(.top, 10)                    .disabled(isRegistering)                                        // Botão de voltar (sem alterações)                    Button(action: {                        withAnimation(.easeInOut) {                            presentationMode.wrappedValue.dismiss()                        }                    }) {                        Text("Voltar para Login")                            .foregroundColor(.blue)                            .padding(.top, 10)                    }                                        // Mensagem de erro (sem alterações)                    if viewModel.mostrarErro {                        Text(viewModel.mensagemErro)                            .foregroundColor(.red)                            .padding(.top)                            .transition(.asymmetric(                                insertion: .opacity.combined(with: .move(edge: .top)),                                removal: .opacity                            ))                    }                                        // MODIFICAÇÃO: Spacer() removido para um layout mais consistente dentro do ScrollView.                }                .padding()            } // Fim do ScrollView            .navigationBarTitle("Registro", displayMode: .inline)            .navigationBarItems(leading: Button(action: {                withAnimation {                    presentationMode.wrappedValue.dismiss()                }            }) {                Image(systemName: "chevron.left")                    .foregroundColor(.blue)            })            .shake($shakeEffect)        }    }}// O resto do seu código (ViewModifiers, Extensions) permanece exatamente o mesmo.// ...struct ShakeEffect: ViewModifier {    var shake: Bool        func body(content: Content) -> some View {        content            .offset(x: shake ? -10 : 0)            .animation(shake ? Animation.default.repeatCount(3).speed(2) : .default, value: shake)    }}extension View {    func shake(_ shake: Binding<Bool>) -> some View {        modifier(ShakeViewModifier(shake: shake))    }}struct ShakeViewModifier: ViewModifier {    @Binding var shake: Bool        func body(content: Content) -> some View {        content            .offset(x: shake ? -10 : 0)            .animation(shake ? Animation.default.repeatCount(3).speed(2) : .default, value: shake)    }}extension String {    func isValidEmail() -> Bool {        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"        let emailPredicate = NSPredicate(format: "SELF MATCHES %@", emailRegex)        return emailPredicate.evaluate(with: self)    }}